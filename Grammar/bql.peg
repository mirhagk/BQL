DotRule = 

Root = stmtList
stmtLine = stmt + semiOpt
semiOpt = ";" / Empty
stmtList = stmtLine+
Id = Id_simple<1,,dot>
stmt = createTableStmt / createIndexStmt / alterStmt / dropTableStmt / dropIndexStmt / selectStmt / insertStmt / updateStmt / deleteStmt / projectionDecl / "GO"
createTableStmt = CREATE TABLE Id "(" fieldDefList ")" constraintListOpt
fieldDefList = fieldDef<1,,comma>
fieldDef = Id typeName typeParamsOpt nullSpecOpt
nullSpecOpt = NULL / NOT NULL / Empty
typeName = "BIT" / "DATE" / "TIME" / "TIMESTAMP" / "DECIMAL" / "REAL" / "FLOAT" / "SMALLINT" / "INTEGER" / "INTERVAL" / "CHARACTER" / "DATETIME" / "INT" / "DOUBLE" / "CHAR" / "NCHAR" / "VARCHAR" / "NVARCHAR" / "IMAGE" / "TEXT" / "NTEXT"
typeParamsOpt = "(" number ")" / "(" number comma number ")" / Empty
constraintDef = CONSTRAINT Id constraintTypeOpt
constraintListOpt = constraintDef*
constraintTypeOpt = PRIMARY KEY idlistPar / UNIQUE idlistPar / NOT NULL idlistPar / "FOREIGN" KEY idlistPar "REFERENCES" Id idlistPar
idlistPar = "(" idlist ")"
idlist = Id<1,,comma>
createIndexStmt = CREATE uniqueOpt INDEX Id ON Id orderList withClauseOpt
uniqueOpt = UNIQUE / Empty
orderList = orderMember<1,,comma>
orderMember = Id orderDirOpt
orderDirOpt = "ASC" / "DESC" / Empty
withClauseOpt = WITH PRIMARY / WITH "DISALLOW" NULL / WITH "IGNORE" NULL | Empty
alterStmt = ALTER TABLE Id alterCmd
alterCmd = ADD COLUMN fieldDefList constraintListOpt / ADD constraintDef / DROP COLUMN Id / DROP CONSTRAINT Id
dropTableStmt = DROP TABLE Id
dropIndexStmt = DROP INDEX Id ON Id
insertStmt = INSERT intoOpt Id idlistPar insertData
insertData = selectStmt / VALUES "(" exprList ")"
intoOpt = INTO / Empty
updateStmt = UPDATE Id SET assignList whereClauseOpt
assignList = assignment<1,,comma>
assignment = Id "=" expression
deleteStmt = DELETE FROM Id whereClauseOpt
selectStmt = selectClause fromClauseOpt whereClauseOpt groupClauseOpt havingClauseOpt orderClauseOpt / fromClause whereClauseOpt groupClauseOpt  havingClauseOpt orderClauseOpt selectClause
selectClause = SELECT selRestrOpt selList intoClauseOpt
selRestrOpt = "ALL" / "DISTINCT" / Empty
selList = columnItemList / "*"
columnItemList = columnItem<1,,comma>
columnItem = projectionRef / columnSource aliasOpt
aliasOpt = asOpt Id / Empty
asOpt = AS / Empty
columnSource = aggregate / Id
aggregate = aggregateName "(" aggregateArg ")"
agrregateArg = expression / "*"
aggregateName = COUNT / "AVG" / "MIN" / "MAX" / "STDEV" / "STDEVP" / "SUM" / "VAR" / "VARP"
intoClauseOpt = INTO Id / Empty
fromClause = FROM idList joinChainOpt
fromClauseOpt = fromClause / Empty
joinChainOpt = joinKindOpt JOIN idlist ON Id "=" Id / Empty
joinKindOpt = "INNER" / "LEFT" outerJoinOpt / "RIGHT" outerJoinOpt / Empty
outerJoinOpt = "OUTER" / Empty
whereClauseOpt = "WHERE" expression / Empty
groupClauseOpt = "GROUP" BY idlist / Empty
havingClauseOpt = "HAVING" expression / Empty
orderClauseOpt = "ORDER" BY orderList / Empty
projectionDecl = PROJECTION Id_simple "(" selList ")"
projectionRef = "<" Id_simple ">" / Id_simple dot "<" Id_simple ">"
exprList = expression<1,,comma>
expression = term / unExpr / binExpr // | betweenExpr // BETWEEN doesn't work - yet; 
term = Id / string_literal / number / funCall / tuple / parSelectStmt
tuple = "(" exprList ")"
parSelectStmt = "(" selectStmt ")"
unExpr = unOp term
unOp = NOT / "+" / "-" / "~"
binExpr  = expression binOp expression
binOp = "+" / "-" / "*" / "/" / "%" / "&" / "|" / "^" / "=" / ">" / "<" / ">=" / "<>" / "!=" / "!<" / "!>" / "AND" / "OR" / "LIKE" / NOT "LIKE" / "IN" / NOT "IN"
betweenExpr = expression notOpt "BETWEEN" expression "AND" expression
notOpt = NOT / Empty
// funCall covers some psedo-operators and special forms like ANY(...), SOME(...), ALL(...), EXISTS(...), IN(...)
funCall = Id "(" funArgs ")"
funArgs = selectStmt / exprList
inStmt = expression "IN" "(" exprList ")"
